# ストリーク開始日時（開始日）・自動カウント要件定義

## 1. 背景 / 現状 (As-Is)

- 現状はダッシュボードの「今日も成功！」押下で日数（ストリーク）をカウントしている。
- DBには `streaks.startedAt`（timestamp）が存在するが、現在は
  - 初回成功で `startedAt` を `new Date()` でセット
  - 失敗で `startedAt = null` に戻す
  - `currentStreak` は日次ボタン操作によって増減
  という動きになっている。

## 2. 目的 (To-Be)

**開始日時（開始日）を一度だけ確定し、その開始日時からの経過時間を自動でカウントして表示する。**

- 日数だけでなく、**時・分・秒**まで表示して「今どれだけ継続できているか」を常に可視化する。
- 開始日時は「スタートしたタイミングのみ」設定でき、**開始後は編集不可**とする（改ざん防止・体験の一貫性）。

## 3. スコープ

### 3.1 対象 (In Scope)

- ダッシュボードのストリーク表示を「自動カウント（開始日時ベース）」にする。
- 開始日時（開始日）の確定フローを追加（初回スタート時のみ）。
- 未開始状態（開始日時が未設定）のUI/挙動定義。
- 再スタート（失敗/リセット後に新しい開始日時で開始）の挙動定義。

### 3.2 対象外 (Out of Scope)

- 通知（プッシュ/メール等）
- マルチタイムゾーン対応の高度化（ユーザーごとのTZ保存など）
- バックグラウンドジョブ（毎日0時に自動でDBの `currentStreak` を更新等）

## 4. 用語

- **開始日時**: ストリーク（継続）を開始した瞬間の日時。DB上は `streaks.startedAt` を想定。
- **経過時間**: 現在時刻 - 開始日時 の差分。
- **ストリーク日数**: 経過時間から算出される「何日目か（何日継続したか）」の表示値。
- **未開始**: 開始日時が未設定（`startedAt = null`）の状態。
- **リセット**: 失敗やアカウント初期化などにより、継続が途切れる（開始日時が無効になる）状態。

## 5. 機能要件

### 5.1 開始日時の確定（スタート）

- **開始日時は初回スタート時にのみ確定できる。**
- 開始日時は基本的に「操作した瞬間の現在時刻」を採用する（= ユーザーが後から日付/時刻を指定して改変できない）。
- 既に開始済み（`startedAt` が存在）の場合、再度開始操作を行っても **開始日時は変更されない**（サーバー側でガードする）。

#### スタートUI案（どちらかを採用）

- **案A（推奨）: 明示的な「スタート」ボタン**
  - 未開始状態のダッシュボードに「オナ禁スタート」ボタンを表示。
  - 押下で開始日時を確定し、タイマー表示へ遷移（同一ページ内でOK）。
- **案B: 既存の「今日も成功！」の初回押下をスタートとみなす**
  - 追加UIが少ない。
  - ただし「成功=日次の結果」なのか「スタート」なのか意味が混ざるため、文言や説明が必要。

### 5.2 自動カウント表示

- ダッシュボードのストリークカードに以下を表示する:
  - **開始日時**（例: `開始: 2025/12/27 21:30`）
  - **経過時間**（例: `経過: 3日 12:34:56`）
  - **ストリーク日数**（例: `4日目` など、既存UIと整合する形）
- 経過時間はクライアント側で **最低1秒間隔**で更新する（ページを開いている間、数字が進む）。
- 未開始（`startedAt = null`）の場合は、経過表示は出さず「未開始」状態を明示する。

### 5.3 ストリーク日数の算出ルール

算出ルールはUXに直結するため、下記のどちらかに統一する。

- **ルール案1（24時間ベース）**
  - 経過時間を \( 24\mathrm{h} \) 単位で割り、`0〜<24h` を「0日目」とする。
  - 例: `days = floor(elapsedSeconds / 86400)`
- **ルール案2（日付ベース / カレンダー日）**
  - 開始日と今日の日付差分（ローカル日付）で「何日目か」を決める。
  - 例: 開始が23:50でも日付が変われば「2日目」になる可能性がある。

※本要件では **どちらを採用するか未確定**（「未確定事項」参照）。

### 5.4 失敗（リセット）と再スタート

最低限、以下の状態遷移を定義する。

- **失敗を記録した場合**
  - 継続は途切れるため、開始日時は無効になる（`startedAt = null`）扱いにする（= 未開始に戻る）。
  - その後、再スタート操作で新しい開始日時を確定できる。
- **アカウント初期化（設定画面のリセット）**
  - 既存の仕様通り、開始日時を含む関連データを初期化する（`startedAt = null`）。

### 5.5 既存の「日次記録（成功/失敗・日記）」との関係

自動カウント導入後も、日次記録は以下のいずれかの位置づけで残す（要選択）。

- **方針A: 日次記録は「振り返り/ログ」のみ（ストリーク表示は開始日時ベース）**
  - 「今日も成功！」は日記・ログ目的で残し、ストリーク日数は開始日時から算出する。
  - 失敗を記録したらタイマーは止まり未開始へ。
- **方針B: 日次記録が正であることを条件にストリークを継続（ハイブリッド）**
  - 開始日時はタイマー用に使うが、毎日「成功」記録がないと継続扱いにしない。
  - 実装が複雑化しやすい（未記録日の扱い・自動失敗判定などが必要）。

※本要件では **方針Aを推奨**（自動カウントの価値が出やすい／UIがシンプル）。

## 6. データ要件（DB/モデル）

### 6.1 既存テーブルの利用

- `streaks.startedAt` を開始日時として利用する。
- 既存の `streaks.currentStreak` / `streaks.maxStreak` は以下のいずれかで扱う（要選択）:
  - **案1: 表示値は算出、DBは互換のため温存（必要なタイミングで更新）**
  - **案2: `currentStreak` を廃止（もしくは参照しない）し、算出のみを正とする**

### 6.2 不整合・移行（既存ユーザー）

- 既に `startedAt` が存在するユーザーは、その値を開始日時としてタイマー表示できる。
- 例外的に以下の不整合があり得るため、表示側での防御を決める:
  - `startedAt = null` だが `currentStreak > 0`
  - `startedAt` が未来（端末時計/データ不整合）

## 7. 画面要件（ダッシュボード）

- ストリークカード（現 `StreakCounter`）に「開始日時」「経過（d/h/m/s）」を追加表示する。
- 未開始の場合:
  - ストリークカードは「未開始」表示＋スタート導線（案Aならボタン、案Bなら説明文）を出す。
- 開始済みの場合:
  - 日数（◯日目）＋経過（時分秒）を常時更新する。

## 8. 非機能要件

- **正確性**: ブラウザがバックグラウンドになった後に戻ってきた場合でも、現在時刻から再計算してズレを最小化する。
- **パフォーマンス**: 1秒更新でもレンダリングが重くならない（最小コンポーネントのみ更新）。
- **セキュリティ/改ざん耐性**: 開始日時の確定はサーバー側で制御し、開始後の変更は拒否する。

## 9. 受け入れ基準（Acceptance Criteria）

- 未開始ユーザーはダッシュボードで「開始」導線が見える。
- 開始操作をすると開始日時が保存され、経過が秒単位で進む表示になる。
- 開始後は開始日時をUIから変更できない（再度開始しても変更されない）。
- 失敗（リセット）を行うと開始日時が無効化され、未開始状態に戻る（再スタートで新しい開始日時）。
- 複数デバイスで開いても、開始日時は1つに確定し、矛盾が起きない。

## 10. 未確定事項（質問）

要件を確定するため、以下を確認したいです。

1. **日数の定義はどちらが良いですか？**
   - 24時間ベース（0〜<24h を1日目） vs 日付ベース（0時跨ぎで2日目）
2. **「失敗」時の挙動**
   - 失敗した瞬間にタイマーは即停止して未開始に戻すでOK？
   - それとも「失敗しても開始日時は保持（通算）」など別概念が必要？
3. **開始操作はどちらのUXにしますか？**
   - 案A: 明示的な「スタート」ボタンを追加
   - 案B: 「今日も成功！」の初回押下をスタート扱い
4. **開始日時の手動指定は必要ですか？**
   - 例: 「実は昨日から始めてたので開始を昨日にしたい」要望を許可するか（許可するなら改ざん耐性とのトレードオフがあります）
5. **自動カウント化後の「今日も成功！」の役割**
   - 日記/振り返り目的として残す（推奨）でOK？
   - それともボタン自体を廃止/別導線にする？


